<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCG Deck Builder</title>
    <style>
	    .profile-icon {
            width: 32px;
            height: 32px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .profile-icon:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        .profile-icon svg {
            color: white;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f7fa;
            color: #333;
        }
        
        /* Navigation Bar */
        .navbar {
            background-color: #4a6cf7;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .navbar h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .navbar-left {
            display: flex;
            align-items: center;
        }
        
        .main-nav-links {
            display: flex;
            gap: 20px;
            margin-left: 30px;
        }
        
        .main-nav-links a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
        }
        
        .nav-links {
            display: flex;
            gap: 20px;
        }
        
        .nav-links a {
            color: white;
            text-decoration: none;
        }
        
        /* Search Area */
        .search-area {
            background-color: white;
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .search-bar {
            width: 300px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .search-container {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .info-icon {
            margin-left: 8px;
            cursor: pointer;
            color: #4a6cf7;
            position: relative;
        }
        
        .search-tooltip {
            position: absolute;
            top: 100%;
            left: 0;
            width: 300px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            z-index: 100;
            font-size: 14px;
            color: #333;
            margin-top: 5px;
        }
        
        .info-icon:hover .search-tooltip {
            display: block;
        }
        
        .filter-dropdown {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }
        
        button {
            background-color: #4a6cf7;
            color: white;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        button.secondary {
            background-color: #e0e0e0;
            color: #333;
        }
        
        /* Main Content Area */
        .content {
            display: flex;
            height: calc(100vh - 125px); /* Adjust based on nav + search height */
        }
        
        /* Card Grid */
        .card-grid-container {
            flex: 3;
            overflow-y: auto;
            padding: 20px;
            background-color: white;
            border-right: 1px solid #ddd;
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            transition: transform 0.2s;
            cursor: pointer;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .placeholder-img {
            width: 100%;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            position: relative;
        }
        
        .monster-card {
            background-color: #ffd699;
        }
        
        .spell-card {
            background-color: #d9b3ff;
        }
        
        .trap-card {
            background-color: #ff99cc;
        }
        
        .card-banner {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            text-align: center;
        }
        
        .card-info {
            padding: 10px;
        }
        
        .card-name {
            font-weight: bold;
            margin: 0 0 5px;
        }
        
        .card-type {
            color: #666;
            font-size: 12px;
        }
        
        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-top: 20px;
        }
        
        .page-button {
            padding: 5px 10px;
            border: 1px solid #ddd;
            background-color: white;
            cursor: pointer;
        }
        
        .page-button.active {
            background-color: #4a6cf7;
            color: white;
            border-color: #4a6cf7;
        }
        
        /* Deck List Area */
        .deck-list-container {
            flex: 1;
            padding: 20px;
            background-color: white;
            overflow-y: auto;
        }
        
        .deck-name-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .deck-name {
            font-size: 20px;
            font-weight: bold;
            margin: 0;
            flex-grow: 1;
        }
        
        .edit-icon {
            cursor: pointer;
            margin-left: 10px;
            color: #4a6cf7;
        }
        
        .deck-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .deck-list {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        
        .deck-card {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .deck-card:last-child {
            border-bottom: none;
        }
        
        .deck-card-name {
            flex-grow: 1;
        }
        
        .deck-card-qty {
            width: 40px;
            text-align: center;
        }
        
        .deck-card-actions {
            display: flex;
            gap: 5px;
        }
        
        .card-counter {
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 60%;
            max-width: 500px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        
        .modal-header h3 {
            margin: 0;
        }
        
        .close-modal {
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .modal-body {
            margin-bottom: 20px;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }
        
        /* Export dialog styles */
        .export-option {
            margin-bottom: 15px;
        }
        
        .export-option h4 {
            margin: 0 0 5px;
        }
        
        .export-url {
            display: block;
            width: 100%;
            padding: 8px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .copy-btn {
            background-color: #e0e0e0;
            color: #333;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .type-indicator {
            display: inline-block; 
            width: 10px; 
            height: 10px; 
            border-radius: 50%; 
            margin-right: 5px;
        }
        
        .monster-indicator {
            background-color: #ffd699;
        }
        
        .spell-indicator {
            background-color: #d9b3ff;
        }
        
        .trap-indicator {
            background-color: #ff99cc;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="navbar-left">
            <h1>TCG Deck Builder</h1>
            <div class="main-nav-links">
                <a href="#">Game</a>
                <a href="#">Deckbuilder</a>
                <a href="#">Rules</a>
            </div>
        </div>
        <div class="nav-links">
            <a href="#">Home</a>
            <div class="profile-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                </svg>
            </div>
        </div>
    </nav>
    
    <!-- Search Area -->
    <div class="search-area">
        <div class="search-container">
            <input type="text" class="search-bar" id="card-search" placeholder="Search cards...">
            <div class="info-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="16" x2="12" y2="12"></line>
                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                </svg>
                <div class="search-tooltip">
                    <strong>Search Tips:</strong>
                    <ul>
                        <li>'cost>3' to find all cards with cost more than 3</li>
                        <li>o:"deals three damage" to find all cards with effects that contain that text</li>
                    </ul>
                </div>
            </div>
        </div>
        <button id="search-btn">Search</button>
        
        <!-- Type dropdown instead of filter button -->
        <select class="filter-dropdown" id="type-filter">
            <option value="">All Types</option>
            <option value="Monster">Monster</option>
            <option value="Spell">Spell</option>
            <option value="Trap">Trap</option>
        </select>
    </div>
    
    <!-- Main Content -->
    <div class="content">
        <!-- Card Grid -->
        <div class="card-grid-container">
            <div class="card-grid" id="card-grid">
                <!-- Cards will be generated here via JavaScript -->
            </div>
            
            <!-- Pagination -->
            <div class="pagination" id="pagination">
                <!-- Pagination will be generated via JavaScript -->
            </div>
        </div>
        
        <!-- Deck List -->
        <div class="deck-list-container">
            <!-- Deck name with edit icon -->
            <div class="deck-name-container">
                <h2 class="deck-name" id="deck-name">New Deck</h2>
                <span class="edit-icon" id="edit-deck-name">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </span>
            </div>
            
            <div class="deck-actions">
                <button id="import-deck">Import</button>
                <button id="export-deck">Export</button>
                <button class="secondary" id="clear-deck">Clear</button>
                <button id="save-deck">Save</button>
            </div>
            
            <div class="deck-list" id="deck-list">
                <!-- Deck cards will be added here via JavaScript -->
                <div class="empty-deck-message">Your deck is empty. Add cards from the grid.</div>
            </div>
            
            <div class="card-counter">
                <span id="deck-count">0</span>/60 Cards
            </div>
        </div>
    </div>
    
    <!-- File upload input (hidden) -->
    <input type="file" id="deck-file-input" style="display: none;" accept=".txt">
    
    <!-- Export Modal -->
    <div class="modal" id="export-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Export Deck</h3>
                <span class="close-modal" id="close-export-modal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="export-option">
                    <h4>Deck Image URL</h4>
                    <input type="text" class="export-url" id="deck-image-url" readonly>
                    <button class="copy-btn" data-target="deck-image-url">Copy</button>
                </div>
                <div class="export-option">
                    <h4>Sharable Deck URL</h4>
                    <input type="text" class="export-url" id="deck-share-url" readonly>
                    <button class="copy-btn" data-target="deck-share-url">Copy</button>
                </div>
            </div>
            <div class="modal-footer">
                <button id="download-deck-btn">Download as Text File</button>
                <button id="close-export-btn" class="secondary">Close</button>
            </div>
        </div>
    </div>

<script>
// Sample card data 
const cardData = [
    // Monster cards
    { id: '001', name: 'Dragon Knight', type: 'Monster', rarity: 'Rare' },
    { id: '002', name: 'Mystic Elf', type: 'Monster', rarity: 'Common' },
    { id: '003', name: 'Fire Dragon', type: 'Monster', rarity: 'Ultra Rare' },
    { id: '004', name: 'Ice Golem', type: 'Monster', rarity: 'Rare' },
    { id: '005', name: 'Dark Assassin', type: 'Monster', rarity: 'Rare' },
    { id: '006', name: 'Ancient Wizard', type: 'Monster', rarity: 'Ultra Rare' },
    { id: '007', name: 'Stone Guardian', type: 'Monster', rarity: 'Common' },
    { id: '008', name: 'Lightning Elemental', type: 'Monster', rarity: 'Uncommon' },
    
    // Spell cards
    { id: '101', name: 'Magic Barrier', type: 'Spell', rarity: 'Common' },
    { id: '102', name: 'Power Boost', type: 'Spell', rarity: 'Rare' },
    { id: '103', name: 'Healing Potion', type: 'Spell', rarity: 'Common' },
    { id: '104', name: 'Arcane Shield', type: 'Spell', rarity: 'Common' },
    { id: '105', name: 'Lightning Bolt', type: 'Spell', rarity: 'Uncommon' },
    { id: '106', name: 'Fireball', type: 'Spell', rarity: 'Common' },
    
    // Trap cards
    { id: '201', name: 'Shadow Trap', type: 'Trap', rarity: 'Uncommon' },
    { id: '202', name: 'Explosive Rune', type: 'Trap', rarity: 'Uncommon' },
    { id: '203', name: 'Counter Spell', type: 'Trap', rarity: 'Rare' },
    { id: '204', name: 'Mirror Force', type: 'Trap', rarity: 'Rare' }
];

// Funny phrases for auto deck naming
const funnyPhrases = [
    "Rampage",
    "Extravaganza",
    "Explosion",
    "Mayhem",
    "Surprise",
    "Avalanche",
    "Fiesta",
    "Apocalypse",
    "Madness",
    "Jamboree"
];

// State variables
let currentPage = 1;
const cardsPerPage = 20; // Reduced to show pagination better
let filteredCards = [...cardData];
const deckCards = new Map(); // Map of card ID to quantity
let deckName = "New Deck";

// Initialize the page
function init() {
    renderCardGrid();
    renderPagination();
    updateDeckCount();
    
    // Add event listeners
    document.getElementById('search-btn').addEventListener('click', handleSearch);
    document.getElementById('card-search').addEventListener('keyup', function(e) {
        if (e.key === 'Enter') {
            handleSearch();
        }
    });
    
    // Type filter dropdown
    document.getElementById('type-filter').addEventListener('change', handleTypeFilter);
    
    document.getElementById('reset-filters').addEventListener('click', resetFilters);
    document.getElementById('filter-rarity').addEventListener('click', showRarityFilter);
    document.getElementById('clear-deck').addEventListener('click', clearDeck);
    document.getElementById('import-deck').addEventListener('click', handleImport);
    document.getElementById('export-deck').addEventListener('click', handleExport);
    document.getElementById('save-deck').addEventListener('click', saveDeck);
    document.getElementById('edit-deck-name').addEventListener('click', editDeckName);
    
    // Export modal events
    document.getElementById('close-export-modal').addEventListener('click', closeExportModal);
    document.getElementById('close-export-btn').addEventListener('click', closeExportModal);
    document.getElementById('download-deck-btn').addEventListener('click', downloadDeckTxt);
    
    // Copy buttons
    document.querySelectorAll('.copy-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const targetId = this.getAttribute('data-target');
            const targetElement = document.getElementById(targetId);
            targetElement.select();
            document.execCommand('copy');
            this.textContent = 'Copied!';
            setTimeout(() => {
                this.textContent = 'Copy';
            }, 2000);
        });
    });
    
    // File input change
    document.getElementById('deck-file-input').addEventListener('change', handleFileUpload);
}

// Function to get an icon based on card type
function getCardTypeIcon(type) {
    switch(type) {
        case 'Monster':
            return '👹';
        case 'Spell':
            return '✨';
        case 'Trap':
            return '⚠️';
        default:
            return '❓';
    }
}

// Render the card grid for the current page
function renderCardGrid() {
    const gridElement = document.getElementById('card-grid');
    gridElement.innerHTML = '';
    
    const startIndex = (currentPage - 1) * cardsPerPage;
    const endIndex = Math.min(startIndex + cardsPerPage, filteredCards.length);
    
    // Fill with actual cards
    for (let i = startIndex; i < endIndex; i++) {
        const card = filteredCards[i];
        const cardElement = document.createElement('div');
        cardElement.className = 'card';
        
        // Determine the card type class for styling
        const cardTypeClass = card.type.toLowerCase() + '-card';
        
        cardElement.innerHTML = `
            <div class="placeholder-img ${cardTypeClass}">
                <div>${getCardTypeIcon(card.type)}</div>
                <div class="card-banner">${card.name}</div>
            </div>
            <div class="card-info">
                <p class="card-name">${card.name}</p>
                <p class="card-type">${card.type} - ${card.rarity}</p>
            </div>
        `;
        
        // Add click event to add card to deck
        cardElement.addEventListener('click', () => addCardToDeck(card));
        
        gridElement.appendChild(cardElement);
    }
}

// Render pagination controls
function renderPagination() {
    const paginationElement = document.getElementById('pagination');
    paginationElement.innerHTML = '';
    
    const totalPages = Math.ceil(filteredCards.length / cardsPerPage);
    
    // Previous button
    const prevButton = document.createElement('button');
    prevButton.className = 'page-button';
    prevButton.textContent = '<<';
    prevButton.disabled = currentPage === 1;
    prevButton.addEventListener('click', () => changePage(currentPage - 1));
    paginationElement.appendChild(prevButton);
    
    // Page buttons
    const maxButtons = 5;
    const startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
    const endPage = Math.min(totalPages, startPage + maxButtons - 1);
    
    for (let i = startPage; i <= endPage; i++) {
        const pageButton = document.createElement('button');
        pageButton.className = 'page-button' + (i === currentPage ? ' active' : '');
        pageButton.textContent = i;
        pageButton.addEventListener('click', () => changePage(i));
        paginationElement.appendChild(pageButton);
    }
    
    // Next button
    const nextButton = document.createElement('button');
    nextButton.className = 'page-button';
    nextButton.textContent = '>>';
    nextButton.disabled = currentPage === totalPages;
    nextButton.addEventListener('click', () => changePage(currentPage + 1));
    paginationElement.appendChild(nextButton);
}

// Change the current page
function changePage(newPage) {
    currentPage = newPage;
    renderCardGrid();
    renderPagination();
    window.scrollTo(0, 0);
}

// Handle search input
function handleSearch() {
    const searchTerm = document.getElementById('card-search').value.trim().toLowerCase();
    
    // Apply current type filter as well
    const typeFilter = document.getElementById('type-filter').value;
    
    if (searchTerm === '' && typeFilter === '') {
        filteredCards = [...cardData];
    } else {
        filteredCards = cardData.filter(card => {
            const matchesSearch = searchTerm === '' || 
                card.name.toLowerCase().includes(searchTerm) || 
                card.rarity.toLowerCase().includes(searchTerm);
            
            const matchesType = typeFilter === '' || card.type === typeFilter;
            
            return matchesSearch && matchesType;
        });
    }
    
    currentPage = 1;
    renderCardGrid();
    renderPagination();
}

// Handle type filter dropdown change
function handleTypeFilter() {
    const typeFilter = document.getElementById('type-filter').value;
    const searchTerm = document.getElementById('card-search').value.trim().toLowerCase();
    
    if (typeFilter === '' && searchTerm === '') {
        filteredCards = [...cardData];
    } else {
        filteredCards = cardData.filter(card => {
            const matchesType = typeFilter === '' || card.type === typeFilter;
            
            const matchesSearch = searchTerm === '' || 
                card.name.toLowerCase().includes(searchTerm) || 
                card.rarity.toLowerCase().includes(searchTerm);
            
            return matchesType && matchesSearch;
        });
    }
    
    currentPage = 1;
    renderCardGrid();
    renderPagination();
}

// Reset all filters
function resetFilters() {
    document.getElementById('card-search').value = '';
    document.getElementById('type-filter').value = '';
    filteredCards = [...cardData];
    currentPage = 1;
    renderCardGrid();
    renderPagination();
}

// Show rarity filter dialog (simplified for demo)
function showRarityFilter() {
    const rarities = ['Common', 'Uncommon', 'Rare', 'Ultra Rare'];
    const rarity = prompt('Filter by rarity: ' + rarities.join(', '));
    
    if (rarity && rarities.some(r => r.toLowerCase() === rarity.toLowerCase())) {
        filteredCards = cardData.filter(card => 
            card.rarity.toLowerCase() === rarity.toLowerCase()
        );
        currentPage = 1;
        renderCardGrid();
        renderPagination();
    }
}

// Add a card to the deck (no limit on copies)
function addCardToDeck(card) {
    const currentQty = deckCards.get(card.id) || 0;
    
    // Check if the deck is full (60 cards max)
    const totalCards = Array.from(deckCards.values()).reduce((sum, qty) => sum + qty, 0);
    if (totalCards >= 60) {
        alert('Your deck is full (max 60 cards).');
        return;
    }
    
    // Add card to deck
    deckCards.set(card.id, currentQty + 1);
    
    // Update the UI
    renderDeckList();
    updateDeckCount();
}

// Render the deck list
function renderDeckList() {
    const deckListElement = document.getElementById('deck-list');
    deckListElement.innerHTML = '';
    
    if (deckCards.size === 0) {
        deckListElement.innerHTML = '<div class="empty-deck-message">Your deck is empty. Add cards from the grid.</div>';
        return;
    }
    
    // Group cards by type for better organization
    const monsterCards = [];
    const spellCards = [];
    const trapCards = [];
    
    deckCards.forEach((qty, id) => {
        const cardInfo = cardData.find(card => card.id === id);
        if (!cardInfo) return;
        
        const deckCard = { ...cardInfo, quantity: qty };
        
        if (cardInfo.type === 'Monster') monsterCards.push(deckCard);
        else if (cardInfo.type === 'Spell') spellCards.push(deckCard);
        else if (cardInfo.type === 'Trap') trapCards.push(deckCard);
    });
    
    // Sort each group alphabetically
    [monsterCards, spellCards, trapCards].forEach(cardGroup => {
        cardGroup.sort((a, b) => a.name.localeCompare(b.name));
    });
    
    // Add type headers and cards
    if (monsterCards.length > 0) {
        addDeckSection('Monster Cards', monsterCards, deckListElement);
    }
    
    if (spellCards.length > 0) {
        addDeckSection('Spell Cards', spellCards, deckListElement);
    }
    
    if (trapCards.length > 0) {
        addDeckSection('Trap Cards', trapCards, deckListElement);
    }
}

// Add a section to the deck list
function addDeckSection(title, cards, container) {
    const sectionHeader = document.createElement('h3');
    sectionHeader.textContent = title;
    container.appendChild(sectionHeader);
    
    cards.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = 'deck-card';
        
        const typeClass = card.type.toLowerCase() + '-indicator';
        
        cardElement.innerHTML = `
            <span class="deck-card-name">
                <span class="type-indicator ${typeClass}"></span>
                ${card.name}
            </span>
            <span class="deck-card-qty">x${card.quantity}</span>
            <div class="deck-card-actions">
                <button class="secondary add-btn">+</button>
                <button class="secondary remove-btn">-</button>
            </div>
        `;
        
        // Add event listeners for quantity buttons
        cardElement.querySelector('.add-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            addCardToDeck(card);
        });
        
        cardElement.querySelector('.remove-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            removeCardFromDeck(card.id);
        });
        
        container.appendChild(cardElement);
    });
}

// Remove a card from the deck
function removeCardFromDeck(cardId) {
    const currentQty = deckCards.get(cardId) || 0;
    
    if (currentQty <= 1) {
        deckCards.delete(cardId);
    } else {
        deckCards.set(cardId, currentQty - 1);
    }
    
    renderDeckList();
    updateDeckCount();
}

// Update the deck count
function updateDeckCount() {
    const totalCards = Array.from(deckCards.values()).reduce((sum, qty) => sum + qty, 0);
    document.getElementById('deck-count').textContent = totalCards;
}

// Clear the deck
function clearDeck() {
    if (deckCards.size === 0) return;
    
    if (confirm('Are you sure you want to clear your deck?')) {
        deckCards.clear();
        renderDeckList();
        updateDeckCount();
    }
}

// Edit deck name
function editDeckName() {
    const newName = prompt('Enter deck name:', deckName);
    if (newName !== null && newName.trim() !== '') {
        deckName = newName.trim();
        document.getElementById('deck-name').textContent = deckName;
    }
}

// Generate a deck name based on most common card
function generateDeckName() {
    // Count occurrences of each card
    const cardCounts = new Map();
    
    deckCards.forEach((qty, id) => {
        const cardInfo = cardData.find(card => card.id === id);
        if (!cardInfo) return;
        
        const cardName = cardInfo.name;
        cardCounts.set(cardName, (cardCounts.get(cardName) || 0) + qty);
    });
    
    // Find the most common card
    let mostCommonCard = null;
    let highestCount = 0;
    
    
    if (!mostCommonCard) return "New Deck";
    
    // Pick a random funny phrase
    const randomPhrase = funnyPhrases[Math.floor(Math.random() * funnyPhrases.length)];
    
    return `${mostCommonCard} ${randomPhrase}`;
}

// Handle import button click - trigger file input
function handleImport() {
    document.getElementById('deck-file-input').click();
}

// Handle file upload
function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            // Parse the deck file content
            const content = e.target.result;
            importDeckFromText(content);
        } catch (err) {
            alert('Error importing deck: Invalid file format');
            console.error(err);
        }
    };
    reader.readAsText(file);
    
    // Reset the file input so the same file can be selected again
    event.target.value = '';
}

// Import deck from text content
function importDeckFromText(content) {
    try {
        // Simple format: cardId:quantity,cardId:quantity,...
        const importedDeck = new Map();
        
        // Split by lines or commas
        const lines = content.split(/[\n,]+/);
        
        lines.forEach(line => {
            const entry = line.trim();
            if (!entry) return;
            
            // Parse format like "cardId:quantity" or just "cardId" (assume quantity 1)
            let cardId, quantity;
            if (entry.includes(':')) {
                [cardId, quantity] = entry.split(':');
                quantity = parseInt(quantity) || 1;
            } else {
                cardId = entry;
                quantity = 1;
            }
            
            // If card exists in our data, add it
            if (cardId && cardData.some(card => card.id === cardId)) {
                importedDeck.set(cardId, (importedDeck.get(cardId) || 0) + quantity);
            }
        });
        
        if (importedDeck.size > 0) {
            deckCards.clear();
            importedDeck.forEach((qty, id) => deckCards.set(id, qty));
            renderDeckList();
            updateDeckCount();
            alert('Deck imported successfully!');
        } else {
            alert('No valid cards found in the imported file.');
        }
    } catch (e) {
        alert('Error importing deck: ' + e.message);
    }
}

// Handle export button click - show modal
function handleExport() {
    if (deckCards.size === 0) {
        alert('Your deck is empty. Add some cards first.');
        return;
    }
    
    // Set up the URLs in the export modal
    const deckId = generateDeckId();
    
    // Image URL (would be generated by the server in a real app)
    document.getElementById('deck-image-url').value = `https://tcg-world.com/deck-image/${deckId}.png`;
    
    // Sharable URL
    document.getElementById('deck-share-url').value = `https://tcg-world.com/decks/${deckId}`;
    
    // Show the modal
    document.getElementById('export-modal').style.display = 'block';
}

// Close export modal
function closeExportModal() {
    document.getElementById('export-modal').style.display = 'none';
}

// Generate a simple deck ID (in a real app, this would be handled by the server)
function generateDeckId() {
    return 'deck_' + Math.random().toString(36).substring(2, 10);
}

// Download deck as a text file
function downloadDeckTxt() {
    // Create deck content
    const deckContent = Array.from(deckCards.entries())
        .map(([id, qty]) => {
            const card = cardData.find(card => card.id === id);
            return `${card.name} (${card.type}): ${qty}`;
        })
        .join('\n');
    
    const blob = new Blob([deckContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    // Create download link
    const a = document.createElement('a');
    a.href = url;
    a.download = `${deckName.replace(/\s+/g, '_')}.txt`;
    document.body.appendChild(a);
    a.click();
    
    // Clean up
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 100);
}

// Save the deck
function saveDeck() {
    if (deckCards.size === 0) {
        alert('Your deck is empty. Add some cards first.');
        return;
    }
    
    // If deck has no name, generate one
    if (deckName === "New Deck") {
        deckName = generateDeckName();
        document.getElementById('deck-name').textContent = deckName;
    }
    
    // In a real app, this would save to a database
    alert(`Deck "${deckName}" saved successfully!`);
}

// Initialize when the page loads
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>